#include "uSE_Quaternion.h"
#include <cmath>

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion::uSE_Quaternion()
{
    m_real = 0;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion::uSE_Quaternion( float inReal, uSE_GLVector inVector ):
    m_real(inReal),
    m_vector(inVector)
{
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion::~uSE_Quaternion()
{
    m_real = 0;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::opposite()
{
    return uSE_Quaternion(-m_real, m_vector.getOpposite());
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::conjugation()
{
    return uSE_Quaternion(m_real, m_vector.getOpposite());
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::reciprocal()
{
    float tmp;
    getNorm(tmp);
    return ( conjugation() * (float)(1.f/tmp) );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void uSE_Quaternion::getNorm( float& outNorm )
{
    float tmp;
    m_vector.getNormSquared(tmp);
    outNorm = m_real*m_real + tmp;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void uSE_Quaternion::normalize()
{
    float norm = 1.f;
    getNorm(norm);

    m_real /= norm;
    m_vector = uSE_GLVector(m_vector.getX() / norm,
                            m_vector.getY() / norm,
                            m_vector.getZ() / norm);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::operator+  ( const uSE_Quaternion &inQuaternion )
{
    return uSE_Quaternion( m_real + inQuaternion.m_real, m_vector + inQuaternion.m_vector);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::operator*  ( const float &inValue )
{
    return uSE_Quaternion(m_real * inValue, m_vector * inValue );
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_Quaternion uSE_Quaternion::operator*  ( const uSE_Quaternion &inQuaternion )
{
    return uSE_Quaternion ( m_real * inQuaternion.m_real - m_vector * inQuaternion.m_vector,
                           (m_vector ^ inQuaternion.m_vector)
                           + (uSE_GLVector)inQuaternion.m_vector * m_real
                           + m_vector * inQuaternion.m_real);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
bool uSE_Quaternion::operator== ( const uSE_Quaternion &inQuaternion )
{
    return (m_real == inQuaternion.m_real && m_vector == inQuaternion.m_vector);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
uSE_GLMatrix  uSE_Quaternion::get_matrix()
{
    return uSE_GLMatrix( 1 - 2*m_vector.getY()*m_vector.getY() - 2*m_vector.getZ()*m_vector.getZ(),
    2*m_vector.getX()*m_vector.getY() + 2*m_real*m_vector.getZ(),
    2*m_vector.getX()*m_vector.getZ() - 2*m_real*m_vector.getY(),
    0,

    2*m_vector.getX()*m_vector.getY() - 2*m_real*m_vector.getZ(),
    1 - 2*m_vector.getX()*m_vector.getX() - 2*m_vector.getZ()*m_vector.getZ(),
    2*m_vector.getY()*m_vector.getZ() + 2*m_real*m_vector.getX(),
    0,

    2*m_vector.getX()*m_vector.getZ() + 2*m_real*m_vector.getY(),
    2*m_vector.getY()*m_vector.getZ() - 2*m_real*m_vector.getX(),
    1 - 2*m_vector.getX()*m_vector.getX() - 2*m_vector.getY()*m_vector.getY(),
    0,

    0,
    0,
    0,
    1);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void uSE_Quaternion::from_axis(uSE_GLVector inAxis, float inDegrees)
{
    float anglerad = M_PI*inDegrees/180.f;
    m_real = cos(anglerad/2.f);
    m_vector = inAxis * sin(anglerad/2.f);
}
